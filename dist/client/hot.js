// client/hot/HMRClient.ts
var HMRClient = class {
  constructor(logger, importUpdatedModule2) {
    this.logger = logger;
    this.importUpdatedModule = importUpdatedModule2;
    Object.assign(globalThis, { hmrClient: this });
  }
  hotModulesMap = /* @__PURE__ */ new Map();
  disposeMap = /* @__PURE__ */ new Map();
  pruneMap = /* @__PURE__ */ new Map();
  dataMap = /* @__PURE__ */ new Map();
  customListenersMap = /* @__PURE__ */ new Map();
  ctxToListenersMap = /* @__PURE__ */ new Map();
  async notifyListeners(event, data) {
    const cbs = this.customListenersMap.get(event);
    if (cbs) {
      await Promise.allSettled(cbs.map((cb) => cb(data)));
    }
  }
  clear() {
    this.hotModulesMap.clear();
    this.disposeMap.clear();
    this.pruneMap.clear();
    this.dataMap.clear();
    this.customListenersMap.clear();
    this.ctxToListenersMap.clear();
  }
  // After an HMR update, some modules are no longer imported on the page
  // but they may have left behind side effects that need to be cleaned up
  // (e.g. style injections)
  async prunePaths(paths) {
    await Promise.all(
      paths.map((path) => {
        const disposer = this.disposeMap.get(path);
        if (disposer) return disposer(this.dataMap.get(path));
      })
    );
    paths.forEach((path) => {
      const fn = this.pruneMap.get(path);
      if (fn) {
        fn(this.dataMap.get(path));
      }
    });
  }
  warnFailedUpdate(err, path) {
    if (!err.message.includes("fetch")) {
      this.logger.error(err);
    }
    this.logger.error(
      `Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`
    );
  }
  updateQueue = [];
  pendingUpdateQueue = false;
  /**
   * buffer multiple hot updates triggered by the same src change
   * so that they are invoked in the same order they were sent.
   * (otherwise the order may be inconsistent because of the http request round trip)
   */
  async queueUpdate(payload) {
    this.updateQueue.push(this.fetchUpdate(payload));
    if (!this.pendingUpdateQueue) {
      this.pendingUpdateQueue = true;
      await Promise.resolve();
      this.pendingUpdateQueue = false;
      const loading = [...this.updateQueue];
      this.updateQueue = [];
      (await Promise.all(loading)).forEach((fn) => fn && fn());
    }
  }
  async fetchUpdate(update) {
    const { path, acceptedPath } = update;
    const mod = this.hotModulesMap.get(path);
    if (!mod) {
      return;
    }
    let fetchedModule;
    const isSelfUpdate = path === acceptedPath;
    const qualifiedCallbacks = mod.callbacks.filter(
      ({ deps }) => deps.includes(acceptedPath)
    );
    console.log(`fetchUpdate`, update, { isSelfUpdate, qualifiedCallbacks, cbs: mod.callbacks });
    if (isSelfUpdate || qualifiedCallbacks.length > 0) {
      const disposer = this.disposeMap.get(acceptedPath);
      if (disposer) await disposer(this.dataMap.get(acceptedPath));
      try {
        fetchedModule = await this.importUpdatedModule(update);
      } catch (e) {
        this.warnFailedUpdate(e, acceptedPath);
      }
    }
    return () => {
      for (const { deps, fn } of qualifiedCallbacks) {
        fn(
          deps.map((dep) => dep === acceptedPath ? fetchedModule : void 0)
        );
      }
      const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;
      this.logger.debug(`hot updated: ${loggedPath}`);
    };
  }
  async update(e) {
    const result = this.testEvent(e);
    if (result) {
      await this.queueUpdate(result);
    }
    return result;
  }
  testEvent(e) {
    const updates = e.map((e2) => ({ path: e2.importer, acceptedPath: e2.url, version: e2.version, timestamp: e2.timestamp }));
    for (const update of updates) {
      const res = this.testUpdate(update);
      if (res?.qualifiedCallbacks.length) {
        return res;
      }
      const res2 = this.testUpdate({
        path: update.acceptedPath,
        acceptedPath: update.acceptedPath,
        version: update.version,
        timestamp: update.timestamp
      });
      if (res2?.qualifiedCallbacks.length) {
        return res2;
      }
    }
  }
  testUpdate(update) {
    const { path, acceptedPath, version, timestamp } = update;
    const mod = this.hotModulesMap.get(path);
    if (!mod) {
      return;
    }
    const isSelfUpdate = path === acceptedPath;
    const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));
    const result = {
      path,
      version,
      timestamp,
      acceptedPath,
      isSelfUpdate,
      qualifiedCallbacks
    };
    return result;
  }
};

// client/hot/HMRContext.ts
var HMRContext = class {
  constructor(hmrClient2, ownerPath) {
    this.hmrClient = hmrClient2;
    this.ownerPath = ownerPath;
    const url = new URL(ownerPath, String(location));
    url.searchParams.delete("version");
    this.ownerPath = ownerPath = String(url);
    console.log(`new HMRContext`, { ownerPath });
    if (!hmrClient2.dataMap.has(ownerPath)) {
      hmrClient2.dataMap.set(ownerPath, {});
    }
    const mod = hmrClient2.hotModulesMap.get(ownerPath);
    if (mod) {
      mod.callbacks = [];
    }
    const staleListeners = hmrClient2.ctxToListenersMap.get(ownerPath);
    if (staleListeners) {
      for (const [event, staleFns] of staleListeners) {
        const listeners = hmrClient2.customListenersMap.get(event);
        if (listeners) {
          hmrClient2.customListenersMap.set(
            event,
            listeners.filter((l) => !staleFns.includes(l))
          );
        }
      }
    }
    this.newListeners = /* @__PURE__ */ new Map();
    hmrClient2.ctxToListenersMap.set(ownerPath, this.newListeners);
  }
  newListeners;
  get data() {
    return this.hmrClient.dataMap.get(this.ownerPath);
  }
  accept(deps, callback) {
    if (typeof deps === "function" || !deps) {
      this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));
    } else if (typeof deps === "string") {
      this.acceptDeps([deps], ([mod]) => callback?.(mod));
    } else if (Array.isArray(deps)) {
      this.acceptDeps(deps, callback);
    } else {
      throw new Error(`invalid hot.accept() usage.`);
    }
  }
  // export names (first arg) are irrelevant on the client side, they're
  // extracted in the server for propagation
  acceptExports(_, callback) {
    this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));
  }
  dispose(cb) {
    this.hmrClient.disposeMap.set(this.ownerPath, cb);
  }
  prune(cb) {
    this.hmrClient.pruneMap.set(this.ownerPath, cb);
  }
  // Kept for backward compatibility (#11036)
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  decline() {
  }
  invalidate(message) {
    this.hmrClient.notifyListeners("hmr:invalidate", {
      path: this.ownerPath,
      message
    });
    this.hmrClient.logger.debug(
      `invalidate ${this.ownerPath}${message ? `: ${message}` : ""}`
    );
  }
  on(event, cb) {
    const addToMap = (map) => {
      const existing = map.get(event) || [];
      existing.push(cb);
      map.set(event, existing);
    };
    addToMap(this.hmrClient.customListenersMap);
    addToMap(this.newListeners);
  }
  off(event, cb) {
    const removeFromMap = (map) => {
      const existing = map.get(event);
      if (existing === void 0) {
        return;
      }
      const pruned = existing.filter((l) => l !== cb);
      if (pruned.length === 0) {
        map.delete(event);
        return;
      }
      map.set(event, pruned);
    };
    removeFromMap(this.hmrClient.customListenersMap);
    removeFromMap(this.newListeners);
  }
  acceptDeps(deps, callback = () => {
  }) {
    deps = deps.map((dep) => {
      const url = new URL(dep, this.ownerPath);
      url.searchParams.delete("version");
      url.searchParams.delete("t");
      return String(url);
    });
    const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {
      id: this.ownerPath,
      callbacks: []
    };
    mod.callbacks.push({
      deps,
      fn: callback
    });
    this.hmrClient.hotModulesMap.set(this.ownerPath, mod);
  }
};

// client/hot/client.ts
var eventSource = new EventSource(import.meta.env.BASE_URL);
eventSource.addEventListener("open", (e) => console.log(`[rpc:sse] connected`, e.target.url));
eventSource.addEventListener("error", (e) => console.log(`[rpc:sse] errored, reloading...`, e.target.url, setTimeout(() => location.reload(), 10)));
eventSource.addEventListener("reload", (e) => e.data === currentUrl() && setTimeout(() => location.reload(), 10));
eventSource.addEventListener("change", (e) => hmrClient.update(JSON.parse(e.data)));
function currentUrl() {
  return location.origin + (location.pathname.endsWith("/") ? location.pathname + "index.html" : location.pathname);
}
function create(meta) {
  return new HMRContext(hmrClient, meta.url);
}
var hmrClient = new HMRClient(
  {
    error: (err) => console.error("[rpc]", err),
    debug: (...msg) => console.debug("[rpc]", ...msg)
  },
  async function importUpdatedModule({
    acceptedPath,
    version,
    explicitImportRequired,
    isWithinCircularImport
  }) {
    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);
    const importUrl = acceptedPathWithoutQuery + `?${explicitImportRequired ? "import&" : ""}version=${version}${query ? `&${query}` : ""}`;
    const importPromise = import(importUrl);
    if (isWithinCircularImport) {
      importPromise.catch(() => {
        console.info(`[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order.`);
        setTimeout(() => location.reload(), 50);
      });
    }
    return await importPromise;
  }
);
export {
  create,
  eventSource,
  hmrClient
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY2xpZW50L2hvdC9ITVJDbGllbnQudHMiLCAiLi4vLi4vY2xpZW50L2hvdC9ITVJDb250ZXh0LnRzIiwgIi4uLy4uL2NsaWVudC9ob3QvY2xpZW50LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBkZW5vLWxpbnQtaWdub3JlLWZpbGUgbm8tZXhwbGljaXQtYW55XG5pbXBvcnQgdHlwZSB7IEN1c3RvbUxpc3RlbmVyc01hcCwgSE1STG9nZ2VyLCBIb3RNb2R1bGUsIEhvdFVwZGF0ZSB9IGZyb20gXCIuL3R5cGVzLnRzXCI7XG5cbmV4cG9ydCBjbGFzcyBITVJDbGllbnQge1xuICAgIHB1YmxpYyBob3RNb2R1bGVzTWFwID0gbmV3IE1hcDxzdHJpbmcsIEhvdE1vZHVsZT4oKVxuICAgIHB1YmxpYyBkaXNwb3NlTWFwID0gbmV3IE1hcDxzdHJpbmcsIChkYXRhOiBhbnkpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+PigpXG4gICAgcHVibGljIHBydW5lTWFwID0gbmV3IE1hcDxzdHJpbmcsIChkYXRhOiBhbnkpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+PigpXG4gICAgcHVibGljIGRhdGFNYXAgPSBuZXcgTWFwPHN0cmluZywgYW55PigpXG4gICAgcHVibGljIGN1c3RvbUxpc3RlbmVyc01hcDogQ3VzdG9tTGlzdGVuZXJzTWFwID0gbmV3IE1hcCgpXG4gICAgcHVibGljIGN0eFRvTGlzdGVuZXJzTWFwID0gbmV3IE1hcDxzdHJpbmcsIEN1c3RvbUxpc3RlbmVyc01hcD4oKVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBsb2dnZXI6IEhNUkxvZ2dlcixcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgaW1wbGVtZW50aW5nIHJlbG9hZGluZyB2aWEgZGlmZmVyZW50IG1ldGhvZHMgZGVwZW5kaW5nIG9uIHRoZSBlbnZpcm9ubWVudFxuICAgICAgICBwcml2YXRlIGltcG9ydFVwZGF0ZWRNb2R1bGU6ICh1cGRhdGU6IEhvdFVwZGF0ZSkgPT4gUHJvbWlzZTxNb2R1bGVOYW1lc3BhY2U+LFxuICAgICkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHsgaG1yQ2xpZW50OiB0aGlzIH0pXG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG5vdGlmeUxpc3RlbmVyczxUIGV4dGVuZHMgc3RyaW5nPihcbiAgICAgICAgZXZlbnQ6IFQsXG4gICAgICAgIGRhdGE6IEluZmVyQ3VzdG9tRXZlbnRQYXlsb2FkPFQ+LFxuICAgICk6IFByb21pc2U8dm9pZD5cblxuICAgIHB1YmxpYyBhc3luYyBub3RpZnlMaXN0ZW5lcnMoZXZlbnQ6IHN0cmluZywgZGF0YTogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNicyA9IHRoaXMuY3VzdG9tTGlzdGVuZXJzTWFwLmdldChldmVudClcbiAgICAgICAgaWYgKGNicykge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNicy5tYXAoKGNiKSA9PiBjYihkYXRhKSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaG90TW9kdWxlc01hcC5jbGVhcigpXG4gICAgICAgIHRoaXMuZGlzcG9zZU1hcC5jbGVhcigpXG4gICAgICAgIHRoaXMucHJ1bmVNYXAuY2xlYXIoKVxuICAgICAgICB0aGlzLmRhdGFNYXAuY2xlYXIoKVxuICAgICAgICB0aGlzLmN1c3RvbUxpc3RlbmVyc01hcC5jbGVhcigpXG4gICAgICAgIHRoaXMuY3R4VG9MaXN0ZW5lcnNNYXAuY2xlYXIoKVxuICAgIH1cblxuICAgIC8vIEFmdGVyIGFuIEhNUiB1cGRhdGUsIHNvbWUgbW9kdWxlcyBhcmUgbm8gbG9uZ2VyIGltcG9ydGVkIG9uIHRoZSBwYWdlXG4gICAgLy8gYnV0IHRoZXkgbWF5IGhhdmUgbGVmdCBiZWhpbmQgc2lkZSBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZSBjbGVhbmVkIHVwXG4gICAgLy8gKGUuZy4gc3R5bGUgaW5qZWN0aW9ucylcbiAgICBwdWJsaWMgYXN5bmMgcHJ1bmVQYXRocyhwYXRoczogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBwYXRocy5tYXAoKHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwb3NlciA9IHRoaXMuZGlzcG9zZU1hcC5nZXQocGF0aClcbiAgICAgICAgICAgICAgICBpZiAoZGlzcG9zZXIpIHJldHVybiBkaXNwb3Nlcih0aGlzLmRhdGFNYXAuZ2V0KHBhdGgpKVxuICAgICAgICAgICAgfSksXG4gICAgICAgIClcbiAgICAgICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm4gPSB0aGlzLnBydW5lTWFwLmdldChwYXRoKVxuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4odGhpcy5kYXRhTWFwLmdldChwYXRoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgd2FybkZhaWxlZFVwZGF0ZShlcnI6IEVycm9yLCBwYXRoOiBzdHJpbmcgfCBzdHJpbmdbXSk6IHZvaWQge1xuICAgICAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdmZXRjaCcpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHJlbG9hZCAke3BhdGh9LiBgICtcbiAgICAgICAgICAgIGBUaGlzIGNvdWxkIGJlIGR1ZSB0byBzeW50YXggZXJyb3JzIG9yIGltcG9ydGluZyBub24tZXhpc3RlbnQgYCArXG4gICAgICAgICAgICBgbW9kdWxlcy4gKHNlZSBlcnJvcnMgYWJvdmUpYCxcbiAgICAgICAgKVxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlUXVldWU6IFByb21pc2U8KCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkPltdID0gW11cbiAgICBwcml2YXRlIHBlbmRpbmdVcGRhdGVRdWV1ZSA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBidWZmZXIgbXVsdGlwbGUgaG90IHVwZGF0ZXMgdHJpZ2dlcmVkIGJ5IHRoZSBzYW1lIHNyYyBjaGFuZ2VcbiAgICAgKiBzbyB0aGF0IHRoZXkgYXJlIGludm9rZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSB3ZXJlIHNlbnQuXG4gICAgICogKG90aGVyd2lzZSB0aGUgb3JkZXIgbWF5IGJlIGluY29uc2lzdGVudCBiZWNhdXNlIG9mIHRoZSBodHRwIHJlcXVlc3Qgcm91bmQgdHJpcClcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgcXVldWVVcGRhdGUocGF5bG9hZDogSG90VXBkYXRlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMudXBkYXRlUXVldWUucHVzaCh0aGlzLmZldGNoVXBkYXRlKHBheWxvYWQpKVxuICAgICAgICBpZiAoIXRoaXMucGVuZGluZ1VwZGF0ZVF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdVcGRhdGVRdWV1ZSA9IHRydWVcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdVcGRhdGVRdWV1ZSA9IGZhbHNlXG4gICAgICAgICAgICBjb25zdCBsb2FkaW5nID0gWy4uLnRoaXMudXBkYXRlUXVldWVdXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVF1ZXVlID0gW11cbiAgICAgICAgICAgICAgICA7IChhd2FpdCBQcm9taXNlLmFsbChsb2FkaW5nKSkuZm9yRWFjaCgoZm4pID0+IGZuICYmIGZuKCkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGZldGNoVXBkYXRlKHVwZGF0ZTogSG90VXBkYXRlKTogUHJvbWlzZTwoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgY29uc3QgeyBwYXRoLCBhY2NlcHRlZFBhdGggfSA9IHVwZGF0ZVxuICAgICAgICBjb25zdCBtb2QgPSB0aGlzLmhvdE1vZHVsZXNNYXAuZ2V0KHBhdGgpXG4gICAgICAgIGlmICghbW9kKSB7XG4gICAgICAgICAgICAvLyBJbiBhIGNvZGUtc3BsaXR0aW5nIHByb2plY3QsXG4gICAgICAgICAgICAvLyBpdCBpcyBjb21tb24gdGhhdCB0aGUgaG90LXVwZGF0aW5nIG1vZHVsZSBpcyBub3QgbG9hZGVkIHlldC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvNzIxXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmZXRjaGVkTW9kdWxlOiBNb2R1bGVOYW1lc3BhY2UgfCB1bmRlZmluZWRcbiAgICAgICAgY29uc3QgaXNTZWxmVXBkYXRlID0gcGF0aCA9PT0gYWNjZXB0ZWRQYXRoXG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBxdWFsaWZpZWQgY2FsbGJhY2tzIGJlZm9yZSB3ZSByZS1pbXBvcnQgdGhlIG1vZHVsZXNcbiAgICAgICAgY29uc3QgcXVhbGlmaWVkQ2FsbGJhY2tzID0gbW9kLmNhbGxiYWNrcy5maWx0ZXIoKHsgZGVwcyB9KSA9PlxuICAgICAgICAgICAgZGVwcy5pbmNsdWRlcyhhY2NlcHRlZFBhdGgpLFxuICAgICAgICApXG5cbiAgICAgICAgY29uc29sZS5sb2coYGZldGNoVXBkYXRlYCwgdXBkYXRlLCB7IGlzU2VsZlVwZGF0ZSwgcXVhbGlmaWVkQ2FsbGJhY2tzLCBjYnM6IG1vZC5jYWxsYmFja3MgfSlcblxuICAgICAgICBpZiAoaXNTZWxmVXBkYXRlIHx8IHF1YWxpZmllZENhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNwb3NlciA9IHRoaXMuZGlzcG9zZU1hcC5nZXQoYWNjZXB0ZWRQYXRoKVxuICAgICAgICAgICAgaWYgKGRpc3Bvc2VyKSBhd2FpdCBkaXNwb3Nlcih0aGlzLmRhdGFNYXAuZ2V0KGFjY2VwdGVkUGF0aCkpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZldGNoZWRNb2R1bGUgPSBhd2FpdCB0aGlzLmltcG9ydFVwZGF0ZWRNb2R1bGUodXBkYXRlKVxuICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXJuRmFpbGVkVXBkYXRlKGUsIGFjY2VwdGVkUGF0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgZGVwcywgZm4gfSBvZiBxdWFsaWZpZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBmbihcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoKGRlcCkgPT4gKGRlcCA9PT0gYWNjZXB0ZWRQYXRoID8gZmV0Y2hlZE1vZHVsZSA6IHVuZGVmaW5lZCkpLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvZ2dlZFBhdGggPSBpc1NlbGZVcGRhdGUgPyBwYXRoIDogYCR7YWNjZXB0ZWRQYXRofSB2aWEgJHtwYXRofWBcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBob3QgdXBkYXRlZDogJHtsb2dnZWRQYXRofWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgdXBkYXRlKGU6IHsgdXJsOiBzdHJpbmcsIHZlcnNpb246IG51bWJlciwgdGltZXN0YW1wOiBudW1iZXIsIGltcG9ydGVyOiBzdHJpbmcgfVtdKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudGVzdEV2ZW50KGUpXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucXVldWVVcGRhdGUocmVzdWx0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBwdWJsaWMgdGVzdEV2ZW50KGU6IHsgdXJsOiBzdHJpbmcsIHZlcnNpb246IG51bWJlciwgdGltZXN0YW1wOiBudW1iZXIsIGltcG9ydGVyOiBzdHJpbmcgfVtdKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBlLm1hcChlID0+ICh7IHBhdGg6IGUuaW1wb3J0ZXIsIGFjY2VwdGVkUGF0aDogZS51cmwsIHZlcnNpb246IGUudmVyc2lvbiwgdGltZXN0YW1wOiBlLnRpbWVzdGFtcCB9KSlcblxuICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRlc3RVcGRhdGUodXBkYXRlKVxuICAgICAgICAgICAgaWYgKHJlcz8ucXVhbGlmaWVkQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlczIgPSB0aGlzLnRlc3RVcGRhdGUoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHVwZGF0ZS5hY2NlcHRlZFBhdGgsXG4gICAgICAgICAgICAgICAgYWNjZXB0ZWRQYXRoOiB1cGRhdGUuYWNjZXB0ZWRQYXRoLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHVwZGF0ZS52ZXJzaW9uLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdXBkYXRlLnRpbWVzdGFtcFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmIChyZXMyPy5xdWFsaWZpZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlczJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHVibGljIHRlc3RVcGRhdGUodXBkYXRlOiBIb3RVcGRhdGUpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoLCBhY2NlcHRlZFBhdGgsIHZlcnNpb24sIHRpbWVzdGFtcCB9ID0gdXBkYXRlXG4gICAgICAgIGNvbnN0IG1vZCA9IHRoaXMuaG90TW9kdWxlc01hcC5nZXQocGF0aClcbiAgICAgICAgaWYgKCFtb2QpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU2VsZlVwZGF0ZSA9IHBhdGggPT09IGFjY2VwdGVkUGF0aFxuICAgICAgICBjb25zdCBxdWFsaWZpZWRDYWxsYmFja3MgPSBtb2QuY2FsbGJhY2tzLmZpbHRlcigoeyBkZXBzIH0pID0+IGRlcHMuaW5jbHVkZXMoYWNjZXB0ZWRQYXRoKSlcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGFjY2VwdGVkUGF0aCxcbiAgICAgICAgICAgIGlzU2VsZlVwZGF0ZSxcbiAgICAgICAgICAgIHF1YWxpZmllZENhbGxiYWNrcyxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGB0ZXN0VXBkYXRlYCwgcmVzdWx0KVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBITVJDbGllbnQgfSBmcm9tIFwiLi9ITVJDbGllbnQudHNcIjtcbmltcG9ydCB0eXBlIHsgQ3VzdG9tTGlzdGVuZXJzTWFwLCBIb3RDYWxsYmFjaywgSG90Q29udGV4dCwgSG90TW9kdWxlIH0gZnJvbSBcIi4vdHlwZXMudHNcIjtcblxuZXhwb3J0IGNsYXNzIEhNUkNvbnRleHQgaW1wbGVtZW50cyBIb3RDb250ZXh0IHtcbiAgICBwcml2YXRlIG5ld0xpc3RlbmVyczogQ3VzdG9tTGlzdGVuZXJzTWFwXG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBobXJDbGllbnQ6IEhNUkNsaWVudCxcbiAgICAgICAgcHJpdmF0ZSBvd25lclBhdGg6IHN0cmluZyxcbiAgICApIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChvd25lclBhdGgsIFN0cmluZyhsb2NhdGlvbikpXG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCd2ZXJzaW9uJylcblxuICAgICAgICB0aGlzLm93bmVyUGF0aCA9IG93bmVyUGF0aCA9IFN0cmluZyh1cmwpXG5cbiAgICAgICAgY29uc29sZS5sb2coYG5ldyBITVJDb250ZXh0YCwgeyBvd25lclBhdGggfSlcblxuICAgICAgICBpZiAoIWhtckNsaWVudC5kYXRhTWFwLmhhcyhvd25lclBhdGgpKSB7XG4gICAgICAgICAgICBobXJDbGllbnQuZGF0YU1hcC5zZXQob3duZXJQYXRoLCB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gYSBmaWxlIGlzIGhvdCB1cGRhdGVkLCBhIG5ldyBjb250ZXh0IGlzIGNyZWF0ZWRcbiAgICAgICAgLy8gY2xlYXIgaXRzIHN0YWxlIGNhbGxiYWNrc1xuICAgICAgICBjb25zdCBtb2QgPSBobXJDbGllbnQuaG90TW9kdWxlc01hcC5nZXQob3duZXJQYXRoKVxuICAgICAgICBpZiAobW9kKSB7XG4gICAgICAgICAgICBtb2QuY2FsbGJhY2tzID0gW11cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIHN0YWxlIGN1c3RvbSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgY29uc3Qgc3RhbGVMaXN0ZW5lcnMgPSBobXJDbGllbnQuY3R4VG9MaXN0ZW5lcnNNYXAuZ2V0KG93bmVyUGF0aClcbiAgICAgICAgaWYgKHN0YWxlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtldmVudCwgc3RhbGVGbnNdIG9mIHN0YWxlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gaG1yQ2xpZW50LmN1c3RvbUxpc3RlbmVyc01hcC5nZXQoZXZlbnQpXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBobXJDbGllbnQuY3VzdG9tTGlzdGVuZXJzTWFwLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmZpbHRlcigobCkgPT4gIXN0YWxlRm5zLmluY2x1ZGVzKGwpKSxcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV3TGlzdGVuZXJzID0gbmV3IE1hcCgpXG4gICAgICAgIGhtckNsaWVudC5jdHhUb0xpc3RlbmVyc01hcC5zZXQob3duZXJQYXRoLCB0aGlzLm5ld0xpc3RlbmVycylcbiAgICB9XG5cbiAgICBnZXQgZGF0YSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5obXJDbGllbnQuZGF0YU1hcC5nZXQodGhpcy5vd25lclBhdGgpXG4gICAgfVxuXG4gICAgYWNjZXB0KGRlcHM/OiBhbnksIGNhbGxiYWNrPzogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ2Z1bmN0aW9uJyB8fCAhZGVwcykge1xuICAgICAgICAgICAgLy8gc2VsZi1hY2NlcHQ6IGhvdC5hY2NlcHQoKCkgPT4ge30pXG4gICAgICAgICAgICB0aGlzLmFjY2VwdERlcHMoW3RoaXMub3duZXJQYXRoXSwgKFttb2RdKSA9PiBkZXBzPy4obW9kKSlcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGV4cGxpY2l0IGRlcHNcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0RGVwcyhbZGVwc10sIChbbW9kXSkgPT4gY2FsbGJhY2s/Lihtb2QpKVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0RGVwcyhkZXBzLCBjYWxsYmFjaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBob3QuYWNjZXB0KCkgdXNhZ2UuYClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4cG9ydCBuYW1lcyAoZmlyc3QgYXJnKSBhcmUgaXJyZWxldmFudCBvbiB0aGUgY2xpZW50IHNpZGUsIHRoZXkncmVcbiAgICAvLyBleHRyYWN0ZWQgaW4gdGhlIHNlcnZlciBmb3IgcHJvcGFnYXRpb25cbiAgICBhY2NlcHRFeHBvcnRzKFxuICAgICAgICBfOiBzdHJpbmcgfCByZWFkb25seSBzdHJpbmdbXSxcbiAgICAgICAgY2FsbGJhY2s/OiAoZGF0YTogYW55KSA9PiB2b2lkLFxuICAgICk6IHZvaWQge1xuICAgICAgICB0aGlzLmFjY2VwdERlcHMoW3RoaXMub3duZXJQYXRoXSwgKFttb2RdKSA9PiBjYWxsYmFjaz8uKG1vZCkpXG4gICAgfVxuXG4gICAgZGlzcG9zZShjYjogKGRhdGE6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhtckNsaWVudC5kaXNwb3NlTWFwLnNldCh0aGlzLm93bmVyUGF0aCwgY2IpXG4gICAgfVxuXG4gICAgcHJ1bmUoY2I6IChkYXRhOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5obXJDbGllbnQucHJ1bmVNYXAuc2V0KHRoaXMub3duZXJQYXRoLCBjYilcbiAgICB9XG5cbiAgICAvLyBLZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5ICgjMTEwMzYpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIGRlY2xpbmUoKTogdm9pZCB7IH1cblxuICAgIGludmFsaWRhdGUobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaG1yQ2xpZW50Lm5vdGlmeUxpc3RlbmVycygnaG1yOmludmFsaWRhdGUnLCB7XG4gICAgICAgICAgICBwYXRoOiB0aGlzLm93bmVyUGF0aCxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuaG1yQ2xpZW50LmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIGBpbnZhbGlkYXRlICR7dGhpcy5vd25lclBhdGh9JHttZXNzYWdlID8gYDogJHttZXNzYWdlfWAgOiAnJ31gLFxuICAgICAgICApXG4gICAgfVxuXG4gICAgb248VCBleHRlbmRzIHN0cmluZz4oXG4gICAgICAgIGV2ZW50OiBULFxuICAgICAgICBjYjogKHBheWxvYWQ6IEluZmVyQ3VzdG9tRXZlbnRQYXlsb2FkPFQ+KSA9PiB2b2lkLFxuICAgICk6IHZvaWQge1xuICAgICAgICBjb25zdCBhZGRUb01hcCA9IChtYXA6IE1hcDxzdHJpbmcsIGFueVtdPikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBtYXAuZ2V0KGV2ZW50KSB8fCBbXVxuICAgICAgICAgICAgZXhpc3RpbmcucHVzaChjYilcbiAgICAgICAgICAgIG1hcC5zZXQoZXZlbnQsIGV4aXN0aW5nKVxuICAgICAgICB9XG4gICAgICAgIGFkZFRvTWFwKHRoaXMuaG1yQ2xpZW50LmN1c3RvbUxpc3RlbmVyc01hcClcbiAgICAgICAgYWRkVG9NYXAodGhpcy5uZXdMaXN0ZW5lcnMpXG4gICAgfVxuXG4gICAgb2ZmPFQgZXh0ZW5kcyBzdHJpbmc+KFxuICAgICAgICBldmVudDogVCxcbiAgICAgICAgY2I6IChwYXlsb2FkOiBJbmZlckN1c3RvbUV2ZW50UGF5bG9hZDxUPikgPT4gdm9pZCxcbiAgICApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlRnJvbU1hcCA9IChtYXA6IE1hcDxzdHJpbmcsIGFueVtdPikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBtYXAuZ2V0KGV2ZW50KVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBydW5lZCA9IGV4aXN0aW5nLmZpbHRlcigobCkgPT4gbCAhPT0gY2IpXG4gICAgICAgICAgICBpZiAocHJ1bmVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hcC5kZWxldGUoZXZlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXAuc2V0KGV2ZW50LCBwcnVuZWQpXG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlRnJvbU1hcCh0aGlzLmhtckNsaWVudC5jdXN0b21MaXN0ZW5lcnNNYXApXG4gICAgICAgIHJlbW92ZUZyb21NYXAodGhpcy5uZXdMaXN0ZW5lcnMpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhY2NlcHREZXBzKFxuICAgICAgICBkZXBzOiBzdHJpbmdbXSxcbiAgICAgICAgY2FsbGJhY2s6IEhvdENhbGxiYWNrWydmbiddID0gKCkgPT4geyB9LFxuICAgICk6IHZvaWQge1xuICAgICAgICBkZXBzID0gZGVwcy5tYXAoZGVwID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoZGVwLCB0aGlzLm93bmVyUGF0aClcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCd2ZXJzaW9uJylcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCd0JylcblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh1cmwpXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgbW9kOiBIb3RNb2R1bGUgPSB0aGlzLmhtckNsaWVudC5ob3RNb2R1bGVzTWFwLmdldCh0aGlzLm93bmVyUGF0aCkgfHwge1xuICAgICAgICAgICAgaWQ6IHRoaXMub3duZXJQYXRoLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBbXSxcbiAgICAgICAgfVxuICAgICAgICBtb2QuY2FsbGJhY2tzLnB1c2goe1xuICAgICAgICAgICAgZGVwcyxcbiAgICAgICAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5obXJDbGllbnQuaG90TW9kdWxlc01hcC5zZXQodGhpcy5vd25lclBhdGgsIG1vZClcbiAgICB9XG59IiwgImltcG9ydCB7IEhNUkNsaWVudCB9IGZyb20gXCIuL0hNUkNsaWVudC50c1wiO1xuaW1wb3J0IHsgSE1SQ29udGV4dCB9IGZyb20gXCIuL0hNUkNvbnRleHQudHNcIjtcbmltcG9ydCB0eXBlIHsgSG90Q29udGV4dCB9IGZyb20gXCIuL3R5cGVzLnRzXCI7XG5cbmV4cG9ydCBjb25zdCBldmVudFNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZShpbXBvcnQubWV0YS5lbnYuQkFTRV9VUkwpXG5cbmV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoZTogYW55KSA9PiBjb25zb2xlLmxvZyhgW3JwYzpzc2VdIGNvbm5lY3RlZGAsIGUudGFyZ2V0LnVybCkpXG5ldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChlOiBhbnkpID0+IGNvbnNvbGUubG9nKGBbcnBjOnNzZV0gZXJyb3JlZCwgcmVsb2FkaW5nLi4uYCwgZS50YXJnZXQudXJsLCBzZXRUaW1lb3V0KCgpID0+IGxvY2F0aW9uLnJlbG9hZCgpLCAxMCkpKVxuZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncmVsb2FkJywgKGUpID0+IGUuZGF0YSA9PT0gY3VycmVudFVybCgpICYmIHNldFRpbWVvdXQoKCkgPT4gbG9jYXRpb24ucmVsb2FkKCksIDEwKSlcbmV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiBobXJDbGllbnQudXBkYXRlKEpTT04ucGFyc2UoZS5kYXRhKSkpXG5cbmZ1bmN0aW9uIGN1cnJlbnRVcmwoKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLm9yaWdpbiArIChsb2NhdGlvbi5wYXRobmFtZS5lbmRzV2l0aCgnLycpXG4gICAgICAgID8gbG9jYXRpb24ucGF0aG5hbWUgKyAnaW5kZXguaHRtbCdcbiAgICAgICAgOiBsb2NhdGlvbi5wYXRobmFtZSlcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKG1ldGE6IEltcG9ydE1ldGEpOiBIb3RDb250ZXh0IHtcbiAgICByZXR1cm4gbmV3IEhNUkNvbnRleHQoaG1yQ2xpZW50LCBtZXRhLnVybClcbn1cblxuZXhwb3J0IGNvbnN0IGhtckNsaWVudCA9IG5ldyBITVJDbGllbnQoXG4gICAge1xuICAgICAgICBlcnJvcjogKGVycikgPT4gY29uc29sZS5lcnJvcignW3JwY10nLCBlcnIpLFxuICAgICAgICBkZWJ1ZzogKC4uLm1zZykgPT4gY29uc29sZS5kZWJ1ZygnW3JwY10nLCAuLi5tc2cpLFxuICAgIH0sXG4gICAgYXN5bmMgZnVuY3Rpb24gaW1wb3J0VXBkYXRlZE1vZHVsZSh7XG4gICAgICAgIGFjY2VwdGVkUGF0aCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgZXhwbGljaXRJbXBvcnRSZXF1aXJlZCxcbiAgICAgICAgaXNXaXRoaW5DaXJjdWxhckltcG9ydCxcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IFthY2NlcHRlZFBhdGhXaXRob3V0UXVlcnksIHF1ZXJ5XSA9IGFjY2VwdGVkUGF0aC5zcGxpdChgP2ApXG4gICAgICAgIGNvbnN0IGltcG9ydFVybCA9IGFjY2VwdGVkUGF0aFdpdGhvdXRRdWVyeSArIGA/JHtleHBsaWNpdEltcG9ydFJlcXVpcmVkID8gJ2ltcG9ydCYnIDogJyd9dmVyc2lvbj0ke3ZlcnNpb259JHtxdWVyeSA/IGAmJHtxdWVyeX1gIDogJyd9YFxuICAgICAgICBjb25zdCBpbXBvcnRQcm9taXNlID0gaW1wb3J0KGltcG9ydFVybClcblxuICAgICAgICBpZiAoaXNXaXRoaW5DaXJjdWxhckltcG9ydCkge1xuICAgICAgICAgICAgaW1wb3J0UHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGBbaG1yXSAke2FjY2VwdGVkUGF0aH0gZmFpbGVkIHRvIGFwcGx5IEhNUiBhcyBpdCdzIHdpdGhpbiBhIGNpcmN1bGFyIGltcG9ydC4gUmVsb2FkaW5nIHBhZ2UgdG8gcmVzZXQgdGhlIGV4ZWN1dGlvbiBvcmRlci5gKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbG9jYXRpb24ucmVsb2FkKCksIDUwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBpbXBvcnRQcm9taXNlXG4gICAgfSxcbikiXSwKICAibWFwcGluZ3MiOiAiO0FBR08sSUFBTSxZQUFOLE1BQWdCO0FBQUEsRUFRbkIsWUFDVyxRQUVDQSxzQkFDVjtBQUhTO0FBRUMsK0JBQUFBO0FBRVIsV0FBTyxPQUFPLFlBQVksRUFBRSxXQUFXLEtBQUssQ0FBQztBQUFBLEVBQ2pEO0FBQUEsRUFiTyxnQkFBZ0Isb0JBQUksSUFBdUI7QUFBQSxFQUMzQyxhQUFhLG9CQUFJLElBQWlEO0FBQUEsRUFDbEUsV0FBVyxvQkFBSSxJQUFpRDtBQUFBLEVBQ2hFLFVBQVUsb0JBQUksSUFBaUI7QUFBQSxFQUMvQixxQkFBeUMsb0JBQUksSUFBSTtBQUFBLEVBQ2pELG9CQUFvQixvQkFBSSxJQUFnQztBQUFBLEVBZS9ELE1BQWEsZ0JBQWdCLE9BQWUsTUFBMEI7QUFDbEUsVUFBTSxNQUFNLEtBQUssbUJBQW1CLElBQUksS0FBSztBQUM3QyxRQUFJLEtBQUs7QUFDTCxZQUFNLFFBQVEsV0FBVyxJQUFJLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFBQSxJQUN0RDtBQUFBLEVBQ0o7QUFBQSxFQUVPLFFBQWM7QUFDakIsU0FBSyxjQUFjLE1BQU07QUFDekIsU0FBSyxXQUFXLE1BQU07QUFDdEIsU0FBSyxTQUFTLE1BQU07QUFDcEIsU0FBSyxRQUFRLE1BQU07QUFDbkIsU0FBSyxtQkFBbUIsTUFBTTtBQUM5QixTQUFLLGtCQUFrQixNQUFNO0FBQUEsRUFDakM7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE1BQWEsV0FBVyxPQUFnQztBQUNwRCxVQUFNLFFBQVE7QUFBQSxNQUNWLE1BQU0sSUFBSSxDQUFDLFNBQVM7QUFDaEIsY0FBTSxXQUFX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
